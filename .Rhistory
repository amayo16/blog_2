Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 15, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 20, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 4, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 5, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 6, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 11, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 9, regression = FALSE,
Levels = unique(y), method = 'minkowski', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 4, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 5, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 10, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 15, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 4, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 5, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'minkowski', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 4, regression = FALSE,
Levels = unique(y), method = 'minkowski', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 5, regression = FALSE,
Levels = unique(y), method = 'minkowski', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 6, regression = FALSE,
Levels = unique(y), method = 'minkowski', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
x2
head(x2)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'minkowski', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
summary(outKNN_2)
# Chunk 1: setup
SAHD <- read.csv('http://math.mercyhurst.edu/~sousley/STAT_139/data/sahdd.csv', as.is = T);
library(class)
library(caret)
# Chunk 2
train <- SAHD[2:10]
trl <- factor(SAHD$chd)
# Chunk 3
train$famhist <- as.factor(train$famhist)
levels(train$famhist) <- 1:length(levels(train$famhist))
train$famhist <- as.numeric(train$famhist)
train$famhist
# Chunk 4
normalize <- function(x) { return ((x - min(x)) / (max(x) - min(x))) }
train_n <- as.data.frame(lapply(train,normalize))
# Chunk 5
k1 <- knn.cv(train_n, trl, k = 1, prob = TRUE)
confusionMatrix(k1, SAHD$chd)
k5 <- knn.cv(train_n, trl, k = 5, prob = TRUE)
confusionMatrix(k5, SAHD$chd)
k11 <- knn.cv(train_n, trl, k = 11, prob = TRUE)
confusionMatrix(k11, SAHD$chd)
k19 <- knn.cv(train_n, trl, k = 19, prob = TRUE)
confusionMatrix(k19, SAHD$chd)
# Chunk 6
library(KernelKnn)
x = train_n
y= SAHD$chd
levels(as.factor(y))[1]
levels(as.factor(y))[2]
y[which( y == levels(as.factor(y))[2])] <- '2'
y[which( y == levels(as.factor(y))[1])] <- '1'
y <- as.numeric(y)
y
k1 <- knn.cv(train_n, trl, k = 1, prob = TRUE)
confusionMatrix(k1, SAHD$chd)
k5 <- knn.cv(train_n, trl, k = 5, prob = TRUE)
confusionMatrix(k5, SAHD$chd)
k11 <- knn.cv(train_n, trl, k = 11, prob = TRUE)
confusionMatrix(k11, SAHD$chd)
k19 <- knn.cv(train_n, trl, k = 19, prob = TRUE)
confusionMatrix(k19, SAHD$chd)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 11, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 9, regression = FALSE,
Levels = unique(y), method = 'minkowski', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
x2 <- train
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'minkowski', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
outKNN_2 <- KernelKnn(x2, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN_2[i,], max(outKNN_2[i,])))
}
confusionMatrix(Classinto,y)
SAHD <- read.csv('http://math.mercyhurst.edu/~sousley/STAT_139/data/sahdd.csv', as.is = T);
library(MASS)
library(caret)
ldfaCV <- lda(chd~sbp+tobacco+ldl+adiposity+famhist+typea+obesity+alcohol+age, data=SAHD, CV = T, priors = c(1,1))  #Cross validated
confusionMatrix(ldfaCV$class, SAHD$chd)
k1 <- knn.cv(train_n, trl, k = 1, prob = TRUE)
confusionMatrix(k1, SAHD$chd)
k5 <- knn.cv(train_n, trl, k = 5, prob = TRUE)
confusionMatrix(k5, SAHD$chd)
k11 <- knn.cv(train_n, trl, k = 11, prob = TRUE)
confusionMatrix(k11, SAHD$chd)
k19 <- knn.cv(train_n, trl, k = 19, prob = TRUE)
confusionMatrix(k19, SAHD$chd)
confusionMatrix(ldfaCV$class, SAHD$chd)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 11, regression = FALSE,
Levels = unique(y), method = 'euclidean', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 9, regression = FALSE,
Levels = unique(y), method = 'minkowski', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
outKNN <- KernelKnn(x, TEST_data = NULL, as.numeric(y), k = 3, regression = FALSE,
Levels = unique(y), method = 'mahalanobis', weights_function = "triangular")
Classinto <- c(0,0,0)
for (i in seq(length(y)))
{
Classinto[i] <- match(1,match(outKNN[i,], max(outKNN[i,])))
}
confusionMatrix(Classinto,y)
Howells <- read.csv('http://math.mercyhurst.edu/~sousley/STAT_139/data/Howells.csv', as.is = T);
attach(Howells);
HBNMF <- Howells[which(Pop == 'NORSE' | Pop == 'BERG'),];
head(HBNMF)
H4A <- na.omit(HBNMF[,c(5:61,63,67:80)])
H4A$PopSex <- as.factor(H4A$PopSex)
table(H4A$PopSex)
BERGF BERGM NORSEF NORSEM
53 56 55 55
# do LOOCV: test each one against n - 1
library(MASS);
library(caret)
H4A.all <- lda(H4A[2:72],H4A$PopSex, data = H4a, prior = c(0.25,0.25,0.25,0.25), CV = T)
confusionMatrix(H4A$PopSex, H4A.all$class)
sprop = 0.3
holdout <- sample(nrow(H4A), round(sprop*nrow(H4A)))
H4A.a7 <- lda(H4A[2:72], H4A$PopSex, data = H4A, prior = c(0.25,0.25,0.25,0.25), subset =
holdout, CV = T)
Accuracies <- c(0.00)
for (i in seq(1000))
{
inTrain <- createDataPartition(y = H4A$PopSex, # y = grouping variable, stratified random split
## the outcome data are needed
p = .70, ## The proportion of records in the training set
list = FALSE)
training <- H4A[inTrain,]
testing <- H4A[-inTrain,]
testrecs <- as.numeric(rownames(testing)) # row(testing)[,1]
H4A.R <- lda(H4A[inTrain,c(2:72)], H4A[inTrain,"PopSex"], data = HA4, prior =
c(0.25,0.25,0.25,0.25), subset = -inTrain, CV = T)
Accuracies[i] <- confusionMatrix(H4A[as.numeric(rownames(H4A.R$posterior)),"PopSex"],
H4A.R$
for (i in seq(1000))
{
inTrain <- createDataPartition(y = H4A$PopSex, # y = grouping variable, stratified random split
## the outcome data are needed
p = .70, ## The proportion of records in the training set
list = FALSE)
training <- H4A[inTrain,]
testing <- H4A[-inTrain,]
testrecs <- as.numeric(rownames(testing)) # row(testing)[,1]
H4A.R <- lda(H4A[inTrain,c(2:72)], H4A[inTrain,"PopSex"], data = HA4, prior =
c(0.25,0.25,0.25,0.25), subset = -inTrain, CV = T)
Accuracies[i] <- confusionMatrix(H4A[as.numeric(rownames(H4A.R$posterior)),"PopSex"],
H4A.R$class)$overall["Accuracy"]
}
summary(Accuracies)
plot(density(Accuracies))
FourStep <- train(PopSex ~ ., data = training, maxvar = 10,
method = "stepLDA", improvement = 0.005,
trControl = trainControl(method = "boot632"))
inTrain <- createDataPartition(y = H4A$PopSex, # y = grouping variable
## the outcome data are needed
p = .80, ## The proportion of records in the training set
list = FALSE)
training <- H4A[ inTrain,]
testing <- H4A[-inTrain,]
nrow(training)
nrow(testing)
# caret uses other methods from packages such as klaR (lda, qda)to do things;
# the other packages have more documentaion on how to run them.
improvement: proportion of improvement: 0.01 = 1 % improvement
maxvar: maximum number of predictors
direct: direction of selection, "forward", "backward", "both" (default)
method: resampling- 'cv' (default k = 10); 'LOOCV', 'boot', 'boot632'
# default: both directions
FourStep <- train(PopSex ~ ., data = training, maxvar = 10,
method = "stepLDA", improvement = 0.005,
trControl = trainControl(method = "boot632"))
library(klaR)
H4A_swf <- stepclass(H4A[2:72], H4A$PopSex, "lda", improvement = 0.005, direction =
"forward", fold = 10)
H4A_swf
plot(H4A_swf)
Accuracies <- c(0.00)
#best model:
#PopSex ~ GOL + XCB + NLH + JUB + XML + FRS + FOL + BAA
for (i in seq(1000))
{
inTrain <- createDataPartition(y = H4A$PopSex, # y = grouping variable, stratified random split
## the outcome data are needed
p = .70, ## The proportion of records in the training set
list = FALSE)
training <- H4A[inTrain,]
testing <- H4A[-inTrain,]
testrecs <- as.numeric(rownames(testing)) # row(testing)[,1]
H4A.RB <- lda(PopSex ~ GOL + XCB + NLH + JUB + XML + FRS + FOL + BAA, data = H4A, prior =
c(0.25,0.25,0.25,0.25), subset = -inTrain, CV = T)
Accuracies[i] <- confusionMatrix(H4A[as.numeric(rownames(H4A.RB$posterior)),"PopSex"],
H4A.RB$class)$overall["Accuracy"]
}
summary(Accuracies)
plot(density(Accuracies))
H4A_swfq <- stepclass(H4A[2:72], H4A$PopSex, "qda", improvement = 0.005,, fold = 5, maxvars = 15)
# multiple times
Accuracies <- c(0.00)
# best QDFA model:
# H4A$PopSex ~ GOL + XCB + OBH + XML + FOL + VRR
for (i in seq(1000))
{
inTrain <- createDataPartition(y = H4A$PopSex, # y = grouping variable, stratified random split
## the outcome data are needed
p = .70, ## The proportion of records in the training set
list = FALSE)
training <- H4A[inTrain,]
testing <- H4A[-inTrain,]
# testrecs <- as.numeric(rownames(testing)) # row(testing)[,1]
H4A.RB <- qda(PopSex ~ GOL + XCB + OBH + XML + FOL + VRR, data = H4A, prior =
c(0.25,0.25,0.25,0.25), subset = -inTrain, CV = T)
Accuracies[i] <- confusionMatrix(H4A[as.numeric(rownames(H4A.RB$posterior)),"PopSex"],
H4A.RB$class)$overall["Accuracy"]
}
summary(Accuracies)
knn4 <- train(PopSex ~ ., data = training, method = "knn",
preProcess = c("center", "scale"), tuneLength = 10,
trControl = trainControl(method = "cv")) update(knn4, list(.k = 3))
knn4 <- train(PopSex ~ ., data = training, method = "knn",
preProcess = c("center", "scale"), tuneLength = 10,
trControl = trainControl(method = "cv"))
update(knn4, list(.k = 3))
knn4 <- train(PopSex ~ ., data = training, method = "knn",
tuneLength = 10,
trControl = trainControl(method = "cv"))
update(knn4, list(.k = 3))
confusionMatrix(knn4)
knn4_pred <- predict(knn4,newdata = testing)
confusionMatrix(knn4_pred,testing$PopSex)
Accuracies <- c(0.00)
# best QDFA model:
# H4A$PopSex ~ GOL + XCB + OBH + XML + FOL + VRR
for (i in seq(20)) # only 20 befcause it takes a while
{
inTrain <- createDataPartition(y = H4A$PopSex, # y = grouping variable, stratified random split
## the outcome data are needed
p = .70, ## The proportion of records in the training set
list = FALSE)
training <- H4A[inTrain,]
testing <- H4A[-inTrain,]
# testrecs <- as.numeric(rownames(testing)) # row(testing)[,1]
knn4 <- train(PopSex ~ ., data = training, method = "knn",
preProcess = c("center", "scale"), tuneLength = 10,
trControl = trainControl(method = "cv"))
update(knn4, list(.k = 3))
knn4_pred <- predict(knn4,newdata = testing)
Accuracies[i] <- confusionMatrix(knn4_pred,testing$PopSex)$overall["Accuracy"]
}
summary(Accuracies)
plot(density(Accuracies))
setwd("C:/Users/Andrew/Desktop/blog_2")
serve_site()
library(devtools)
library(blogdown)
serve_site()
serve_site()
serve_site()
serve_site()
serve_site()
serve_site()
serve_site()
